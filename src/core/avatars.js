// Emoji avatars + unlock helpers.
// Rule: 2 avatars per Start Level (L0 => 2, L1 => 4, ...).

export const AVATARS = [
  // Faces
  "ðŸ˜€","ðŸ˜ƒ","ðŸ˜„","ðŸ˜","ðŸ˜†","ðŸ˜…","ðŸ¤£","ðŸ˜‚","ðŸ™‚","ðŸ™ƒ",
  "ðŸ˜‰","ðŸ˜Š","ðŸ˜‡","ðŸ¥°","ðŸ˜","ðŸ¤©","ðŸ˜˜","ðŸ˜—","ðŸ˜š","ðŸ˜™",
  "ðŸ˜‹","ðŸ˜›","ðŸ˜œ","ðŸ¤ª","ðŸ˜","ðŸ¤‘","ðŸ¤—","ðŸ¤­","ðŸ¤«","ðŸ¤”",
  "ðŸ¤¨","ðŸ˜","ðŸ˜‘","ðŸ˜¶","ðŸ«¥","ðŸ˜","ðŸ˜’","ðŸ™„","ðŸ˜¬","ðŸ˜®â€ðŸ’¨",
  "ðŸ˜Œ","ðŸ˜”","ðŸ˜ª","ðŸ¤¤","ðŸ˜´","ðŸ˜·","ðŸ¤’","ðŸ¤•","ðŸ¤¢","ðŸ¤®",
  "ðŸ¥µ","ðŸ¥¶","ðŸ˜µ","ðŸ˜µâ€ðŸ’«","ðŸ¤¯","ðŸ˜Ž","ðŸ¥³","ðŸ˜ˆ","ðŸ‘¿","ðŸ’€",

  // People / roles
  "ðŸ‘¶","ðŸ§’","ðŸ‘¦","ðŸ‘§","ðŸ§‘","ðŸ‘¨","ðŸ‘©","ðŸ§”","ðŸ‘¨â€ðŸ¦±","ðŸ‘©â€ðŸ¦°",
  "ðŸ§™","ðŸ§š","ðŸ§›","ðŸ§Ÿ","ðŸ§ž","ðŸ§œ","ðŸ§","ðŸ¥·","ðŸ¦¸","ðŸ¦¹",

  // Animals
  "ðŸ¶","ðŸ±","ðŸ­","ðŸ¹","ðŸ°","ðŸ¦Š","ðŸ»","ðŸ¼","ðŸ¨","ðŸ¯",
  "ðŸ¦","ðŸ®","ðŸ·","ðŸ¸","ðŸµ","ðŸ™ˆ","ðŸ™‰","ðŸ™Š","ðŸ”","ðŸ§",
  "ðŸ¦","ðŸ¦‰","ðŸ¦‡","ðŸº","ðŸ—","ðŸ´","ðŸ¦„","ðŸ","ðŸª²","ðŸ¦‹",

  // Nature
  "ðŸŒµ","ðŸŒ²","ðŸŒ³","ðŸŒ´","ðŸŒ±","ðŸ€","ðŸŒ¿","ðŸŒº","ðŸŒ¸","ðŸŒ¼",
  "ðŸŒ™","â­","ðŸŒŸ","âœ¨","âš¡","ðŸ”¥","ðŸ’§","â„ï¸","ðŸŒˆ","â˜€ï¸",

  // Objects / icons
  "ðŸŽ¯","ðŸŽ®","ðŸ•¹ï¸","ðŸŽ²","â™Ÿï¸","ðŸ§©","ðŸŽ§","ðŸŽµ","ðŸŽ¸","ðŸ¥",
  "ðŸ“Œ","ðŸ“Ž","ðŸ’Ž","ðŸ”®","ðŸ§ª","ðŸ§¬","ðŸ›°ï¸","ðŸš€","ðŸ›¸","ðŸ¤–",
  "ðŸ‘¾","ðŸ§ ","ðŸ›¡ï¸","âš”ï¸","ðŸ¹","ðŸ”«","ðŸ’£","ðŸ§¨","ðŸ”§","âš™ï¸",

  // Symbols
  "â¤ï¸","ðŸ§¡","ðŸ’›","ðŸ’š","ðŸ’™","ðŸ’œ","ðŸ¤","ðŸ–¤","ðŸ’”","ðŸ’¥",
  "âœ…","âŒ","âš ï¸","ðŸ’«","ðŸ’¤","ðŸŒ€","ðŸ‘‘","ðŸ†","ðŸ¥‡","ðŸ”±",
];

export function getUnlockedAvatarCount(startLevel) {
  const L = Math.max(0, (startLevel | 0));
  // L0 => 2, L1 => 4, ...
  return Math.max(2, Math.min(AVATARS.length, 2 * (L + 1)));
}

export function isAvatarUnlocked(startLevel, avatarIndex) {
  const idx = avatarIndex | 0;
  if (idx < 0) return false;
  return idx < getUnlockedAvatarCount(startLevel);
}

export function clampAvatarIndex(startLevel, avatarIndex) {
  const idx = Math.max(0, avatarIndex | 0);
  const unlocked = getUnlockedAvatarCount(startLevel);
  // Keep within unlocked range; if somehow out-of-range, fall back to last unlocked.
  return Math.min(idx, Math.max(0, unlocked - 1));
}
